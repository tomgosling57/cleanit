#!/usr/bin/env python3
import secrets
import string
import os
import sys
import glob

def random_string(length=32):
    alphabet = string.ascii_letters + string.digits
    return "".join(secrets.choice(alphabet) for _ in range(length))


ENV_VARS = [
    {
        "name": "POSTGRES_DB",
        "default": "cleanit",
        "random": False,
        "required": True,
    },
    {
        "name": "POSTGRES_USER",
        "default": "cleanit_user",
        "random": False,
        "required": True,
    },
    {
        "name": "POSTGRES_PASSWORD",
        "default": "",
        "random": True,
        "required": True,
        "validation": lambda x: len(x) > 0,
        "validation_msg": "Password cannot be empty",
    },
    {
        "name": "MINIO_ROOT_USER",
        "default": "minioadmin",
        "random": False,
        "required": True,
    },
    {
        "name": "MINIO_ROOT_PASSWORD",
        "default": "minioadmin",
        "random": True,
        "required": True,
        "validation": lambda x: len(x) > 0,
        "validation_msg": "Password cannot be empty",
    },
    {
        "name": "SECRET_KEY",
        "default": "",
        "random": True,
        "required": True,
        "validation": lambda x: len(x) > 0,
        "validation_msg": "Secret key cannot be empty",
    },
    {
        "name": "S3_BUCKET",
        "default": "cleanit-media",
        "random": False,
        "required": True,
    },
    {
        "name": "S3_ENDPOINT_URL",
        "default": "http://minio:9000",
        "random": False,
        "required": True,
    },
    {
        "name": "AWS_REGION",
        "default": "us-east-1",
        "random": False,
        "required": True,
    },
    {
        "name": "AWS_ACCESS_KEY_ID",
        "default": "minioadmin",
        "random": False,
        "required": True,
    },
    {
        "name": "AWS_SECRET_ACCESS_KEY",
        "default": "minioadmin",
        "random": True,
        "required": True,
        "validation": lambda x: len(x) > 0,
        "validation_msg": "Secret key cannot be empty",
    },
    {
        "name": "FLASK_ENV",
        "default": "production",
        "random": False,
        "required": True,
        "validation": lambda x: x in ["production", "debug", "testing"],
        "validation_msg": "FLASK_ENV must be one of: production, debug, testing",
    },
]


def find_env_files():
    """Find all environment files in the project"""
    env_patterns = ['.env', '.env.*', '*.env']
    env_files = []
    
    for pattern in env_patterns:
        env_files.extend(glob.glob(pattern))
    
    # Remove duplicates and sort
    env_files = sorted(set(env_files))
    return env_files


def load_existing_env(env_file=".env"):
    """Load existing environment variables from .env file if it exists"""
    if not os.path.exists(env_file):
        return {}
    
    existing = {}
    try:
        with open(env_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    existing[key.strip()] = value.strip()
    except Exception as e:
        print(f"Warning: Could not read existing {env_file} file: {e}")
    
    return existing


def prompt(var, existing_value=None):
    name = var["name"]
    default = var["default"]
    allow_random = var["random"]
    required = var.get("required", False)
    validation = var.get("validation")
    validation_msg = var.get("validation_msg", "Invalid value")
    
    # Use existing value as default if available
    if existing_value is not None:
        default = existing_value
    
    prompt_parts = [name]
    if default:
        prompt_parts.append(f"default: {default}")
    if allow_random:
        prompt_parts.append("type 'random' to generate")
    
    prompt_text = " (" + ", ".join(prompt_parts[1:]) + ")" if len(prompt_parts) > 1 else ""
    
    while True:
        value = input(f"{name}{prompt_text}: ").strip()
        
        if value.lower() == "random" and allow_random:
            value = random_string()
        
        if value == "":
            value = default
        
        # Check if required field is empty
        if required and not value:
            print(f"Error: {name} is required")
            continue
        
        # Run validation if provided
        if validation and not validation(value):
            print(f"Error: {validation_msg}")
            continue
        
        return value


def write_env_file(results, env_file=".env"):
    """Write environment variables to .env file"""
    try:
        with open(env_file, 'w') as f:
            f.write("# CleanIt Environment Variables\n")
            f.write("# Generated by set_environment_variables.py\n")
            f.write("# DO NOT commit this file to version control\n\n")
            
            for key, value in results.items():
                f.write(f"{key}={value}\n")
        
        print(f"\n‚úÖ Environment variables written to {env_file}")
        print(f"   File contains {len(results)} variables")
        
        # Set file permissions to be more secure
        os.chmod(env_file, 0o600)
        print(f"   File permissions set to 600 (owner read/write only)")
        
    except Exception as e:
        print(f"Error writing to {env_file}: {e}")
        return False
    
    return True


def main():
    print("\n" + "="*60)
    print("CleanIt Environment Variable Setup")
    print("="*60)
    
    # Find all existing environment files
    env_files = find_env_files()
    
    if env_files:
        print(f"\nüìÅ Found {len(env_files)} environment file(s) in project:")
        for i, env_file in enumerate(env_files, 1):
            size = os.path.getsize(env_file) if os.path.exists(env_file) else 0
            print(f"   {i}. {env_file} ({size} bytes)")
        
        print("\nOptions:")
        print("  1. Update existing .env file")
        print("  2. Create new .env file with different name")
        print("  3. Cancel")
        
        choice = input("\nSelect option [1/2/3]: ").strip()
        
        if choice == "3":
            print("Cancelled.")
            return
        elif choice == "2":
            env_file = input("Enter new environment file name (e.g., .env.dev, .env.test): ").strip()
            if not env_file:
                env_file = ".env"
            existing_env = {}
        else:
            # Default to .env if it exists, otherwise ask
            if ".env" in env_files:
                env_file = ".env"
            else:
                print("\nAvailable environment files:")
                for i, env_file_option in enumerate(env_files, 1):
                    print(f"  {i}. {env_file_option}")
                file_choice = input(f"\nSelect file to update [1-{len(env_files)}]: ").strip()
                try:
                    idx = int(file_choice) - 1
                    if 0 <= idx < len(env_files):
                        env_file = env_files[idx]
                    else:
                        env_file = ".env"
                except:
                    env_file = ".env"
            
            existing_env = load_existing_env(env_file)
    else:
        env_file = ".env"
        existing_env = {}
        print(f"\nNo existing environment files found. Creating {env_file}...")
    
    print(f"\nUsing environment file: {env_file}")
    
    if existing_env:
        print(f"Loaded {len(existing_env)} existing variables as defaults")
    
    print("\nFLASK_ENV valid values:")
    print("  - production: Default production configuration with S3 storage")
    print("  - debug: Development configuration with auto-reloading and debug features")
    print("  - testing: Testing configuration with temporary storage")
    print("\nFor passwords and secret keys, type 'random' to generate secure random values.")
    print("-" * 60)
    
    results = {}
    
    for var in ENV_VARS:
        name = var["name"]
        existing_value = existing_env.get(name)
        results[name] = prompt(var, existing_value)
    
    print("\n" + "="*60)
    print("Summary of environment variables:")
    print("="*60)
    
    for key, value in results.items():
        if "PASSWORD" in key or "SECRET" in key:
            display_value = "*****" + value[-4:] if len(value) > 4 else "*****"
        else:
            display_value = value
        print(f"{key:25} = {display_value}")
    
    print("\n" + "-"*60)
    write_choice = input(f"Write to {env_file}? (y/n): ").strip().lower()
    
    if write_choice in ['y', 'yes']:
        if write_env_file(results, env_file):
            print("\n‚úÖ Setup complete!")
            print(f"\nEnvironment file: {env_file}")
            print("\nNext steps:")
            print("1. Run: docker compose --env-file {env_file} up -d")
            print("2. Check logs: docker compose logs -f")
            print("3. Access the app at http://localhost:5000")
        else:
            print("\n‚ùå Failed to write environment file")
            print("\nYou can manually create the file with the values above:")
            for key, value in results.items():
                print(f"{key}={value}")
    else:
        print("\nEnvironment variables (copy to file):")
        print("-" * 48)
        for key, value in results.items():
            print(f"{key}={value}")
        print(f"\nTip: Save to file with: python set_environment_variables.py > {env_file}")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nSetup cancelled.")
        sys.exit(1)
